奶牛吃草
时间限制：4 sec

空间限制：256 MB

问题描述
有一只奶牛在一条笔直的道路上（可以看做是一个数轴）。初始，它在道路上坐标为 K 的地方。

这条道路上有 n 棵非常新鲜的青草（编号从 1 开始）。其中第 i 棵青草位于道路上坐标为 x[i] 的地方。贝西每秒钟可以沿着道路的方向向前（坐标加）或向后（坐标减）移动一个坐标单位的距离。

它只要移动到青草所在的地方，就可以一口吞掉青草，它的食速很快，吃草的时间可以不计。

它要吃光所有的青草。不过，青草太新鲜了，在被吞掉之前，暴露在道路上的每棵青草每秒种都会损失一单位的口感。

请你帮它计算，该怎样来回跑动，才能在口感损失之和最小的情况下吃掉所有的青草。

输入格式
第一行两个用空格隔开的整数 n,k，分别表示青草的数目和奶牛的初始坐标。

第 2 行到第 n+1 行，第 i+1 行有一个整数 x[i]，描述第 i 棵青草的坐标。

输出格式
一行一个整数，表示吃掉所有青草的前提下，最小损失的口感之和。保证答案在 32 位有符号整数的范围内。

样例输入
4 10
1
9
11
19
样例输出
44
样例解释
先跑到 9，然后跑到 11，再跑到 19，最后到 1，可以让损失的口感总和为 29+1+3+11=44。可以证明不存在比这更优的解。

数据范围
对于 50% 的数据，保证 1≤n≤4，1≤k,x[i]≤20。 对于 80% 的数据，保证 1≤n≤100。 对于 100% 的数据，保证 1≤n≤1000，1≤k,x[i]≤10^6。

提示
[我们先从另一个角度看答案，即损失的总口感：从初始状态到奶牛吃掉第 1 棵草之间的时间（我们在下面把它叫做第 1 段时间），所有的 n 棵青草都在流失口感；……；从奶牛吃掉第 i 棵草到它吃掉第 i+1 棵草之间的时间（我们在下面把它叫做第 i+1 段时间），还没有被吃掉的 n-i 棵草都在流失口感；……]

[于是我们发现，第 i 段时间对答案的贡献，为这段时间的长度与 n-i+1 的乘积。]

[接着，我们再来关注最优策略。吃完一棵草后（包括初始时），奶牛的最优策略一定是直奔另一棵草。]

[由于奶牛不会飞，所以奶牛走过的所有路一定是一段连续的区间。]

[显然地，被奶牛经过过的地方，按最优策略，一定不会留下青草。]

[所以我们可以**将所有青草的坐标排序**（下面我们都使用排完序后的编号），然后用 dp[l][r][j] 表示吃完 [l,r] 范围内的青草时的最小答案，j 只有 0,1 两种取值，分别表示奶牛吃完最后一棵草停在青草 l 还是 r 上（只有可能是这两种情况，否则与上面的结论矛盾）。]

[于是我们就可以轻易地设计出状态转移方程：]

[dp[l][r][0]=min(dp[l+1][r][0]+(n-r+l)*abs(x[l]-x[l+1]),dp[l+1][r][1]+(n-r+l)*abs(x[l]-x[r]))]

[dp[l][r][1]=min(dp[l][r-1][1]+(n-r+l)*abs(x[r]-x[r-1]),dp[l][r-1][0]+(n-r+l)*abs(x[r]-x[l]))]

[边界为：dp[i][i][j]=abs(x[i]-k)*n（对于所有1<=i<=n，j=0,1）]

[友情提示：请注意枚举顺序。]

另外，为了帮助大家完成题目，我们提供了只包含了输入输出功能的程序模板，也提供了含有算法的大部分实现细节的程序。

你可以根据自己的实际情况，在这些程序的基础上进行作答，或不参考这些程序，这将与你的得分无关。

这些程序可以从【这里】下载。

Source
[来自 USACO 月赛（具体场次已无从考究）]

